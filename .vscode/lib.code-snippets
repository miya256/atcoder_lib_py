{
  "SegmentTree": {
    "prefix": "class SegmentTree",
    "body": [
      "from typing import Generic, TypeVar, Callable, Iterator",
      "",
      "Monoid = TypeVar(\"Monoid\")",
      "",
      "class SegmentTree(Generic[Monoid]):",
      "    \"\"\"",
      "    一点更新、区間取得を O(log n) で計算",
      "",
      "    Attributes:",
      "        op(x, y): xとyの二項演算（関数型）",
      "        e       : opの単位元",
      "",
      "    Methods:",
      "        get(i)    : i番目を取得",
      "        set(i, x) : i番目をxにする",
      "        prod(i, x): 区間[l, r)の積",
      "        all_prod(): 全体の積    ",
      "        max_right(l, condition): condition(prod[l,j))が真になる最大のjを返す",
      "        min_left(r, condition) : condition(prod[j,r))が真になる最小のjを返す",
      "    \"\"\"",
      "    ",
      "    def __init__(",
      "        self,",
      "        op: Callable[[Monoid, Monoid], Monoid],",
      "        e: Monoid,",
      "        data: list[Monoid] | int",
      "    ) -> None:",
      "        if isinstance(data, int):",
      "            data = [e for _ in range(data)]",
      "        self._n = len(data)",
      "        self._op = op",
      "        self._e = e",
      "        self._size = 1 << (len(data)-1).bit_length() # 最下段の長さ",
      "        self._tree = [e for _ in range(self._size*2)] # tree[1]が最上段,tree[size]が元のdata[0]",
      "        self._build(data)",
      "    ",
      "    def _build(self, data: list[Monoid]) -> None:",
      "        for i, val in enumerate(data):",
      "            self._tree[i+self._size] = val",
      "        for i in range(self._size-1, 0, -1):",
      "            self._update(i)",
      "    ",
      "    def __len__(self) -> int:",
      "        return self._n",
      "    ",
      "    def __getitem__(self, i: int) -> Monoid:",
      "        \"\"\"i番目を取得\"\"\"",
      "        return self.get(i)",
      "    ",
      "    def __setitem__(self, i: int, x: Monoid) -> None:",
      "        \"\"\"i番目にxを代入\"\"\"",
      "        self.set(i, x)",
      "",
      "    def __iter__(self) -> Iterator[Monoid]:",
      "        for i in range(self._n):",
      "            yield self.get(i)",
      "    ",
      "    def __repr__(self) -> str:",
      "        return f'SegmentTree {list(self)}'",
      "    ",
      "    def get(self, i: int) -> Monoid:",
      "        \"\"\"i番目を取得\"\"\"",
      "        assert 0 <= i < self._n, f\"index error i={i}\"",
      "        return self._tree[i+self._size]",
      "    ",
      "    def set(self, i: int, x: Monoid) -> None:",
      "        \"\"\"i番目にxを代入\"\"\"",
      "        assert 0 <= i < self._n, f\"index error i={i}\"",
      "        i += self._size",
      "        self._tree[i] = x",
      "        while i:",
      "            i >>= 1",
      "            self._update(i)",
      "    ",
      "    def prod(self, l: int, r: int) -> Monoid:",
      "        \"\"\"区間[l, r)の積\"\"\"",
      "        assert 0 <= l <= r <= self._n, f\"index error [l,r)=[{l},{r})\"",
      "        lt, rt = self._e, self._e",
      "        l += self._size",
      "        r += self._size",
      "        while l < r:",
      "            if l & 1: #右側だけなら",
      "                lt = self._op(lt, self._tree[l])",
      "                l += 1 #上は範囲外も含むから一つ右にずらす",
      "            if r & 1: #左側だけなら",
      "                r -= 1",
      "                rt = self._op(self._tree[r], rt)",
      "            l >>= 1",
      "            r >>= 1",
      "        return self._op(lt, rt)",
      "    ",
      "    def all_prod(self) -> Monoid:",
      "        \"\"\"全体の積\"\"\"",
      "        return self._tree[1]",
      "    ",
      "    def max_right(self, l: int, condition: Callable[[Monoid], bool]) -> int:",
      "        \"\"\"condition(prod[l,j))が真になる最大のjを返す\"\"\"",
      "        assert 0 <= l <= self._n, f\"index error l={l}\"",
      "        if l == self._n:",
      "            return self._n",
      "        ",
      "        l += self._size",
      "        val = self._e #確定した区間の積",
      "        while True:",
      "            while not l & 1: #右ノードになるまで親に移動",
      "                l >>= 1",
      "            if not condition(self._op(val, self._tree[l])):",
      "                while l < self._size: #下まで",
      "                    l <<= 1 #左の子に移動",
      "                    if condition(self._op(val, self._tree[l])): #満たすなら",
      "                        val = self._op(val, self._tree[l]) #左は確定して",
      "                        l += 1 #同じ段の右ノードに移動",
      "                return l - self._size",
      "            val = self._op(val, self._tree[l]) #満たすなら確定する",
      "            l += 1 #右に移動",
      "            if l & -l == l: #condition(prod(l,n)) = Trueなら(lが2の累乗)",
      "                return self._n #一番右を返す",
      "        ",
      "    def min_left(self, r: int, condition: Callable[[Monoid], bool]) -> int:",
      "        \"\"\"condition(prod[j,r))が真になる最小のjを返す\"\"\"",
      "        assert 0 <= r <= self._n, f\"index error r={r}\"",
      "        if r == 0:",
      "            return 0",
      "        ",
      "        r += self._size",
      "        val = self._e",
      "        while True:",
      "            while not r & 1:",
      "                r >>= 1",
      "            if not condition(self._op(val, self._tree[r-1])):",
      "                while r < self._size:",
      "                    r <<= 1",
      "                    if condition(self._op(val, self._tree[r-1])):",
      "                        r -= 1",
      "                        val = self._op(val, self._tree[r])",
      "                return r - self._size",
      "            r -= 1",
      "            val = self._op(val, self._tree[r])",
      "            if r & -r == r:",
      "                return 0",
      "    ",
      "    def _update(self, i: int) -> None:",
      "        self._tree[i] = self._op(self._tree[2*i], self._tree[2*i+1])",
      ""
    ],
    "description": "Auto snippet for SegmentTree"
  },
  "FenwickTree": {
    "prefix": "class FenwickTree",
    "body": [
      "from typing import Iterator",
      "",
      "class FenwickTree:",
      "    \"\"\"",
      "    区間の和を O(log n) で計算",
      "",
      "    Methods:\\n",
      "        get(i)         : i番目を取得",
      "        set(i, x)      : i番目をxにする",
      "        add(i, x)      : i番目にxを加算",
      "        sum(l, r)      : 区間[l, r)の和",
      "        bisect_left(x) : 累積和配列とみなし、二分探索",
      "        bisect_right(x): 累積和配列とみなし、二分探索",
      "    \"\"\"",
      "",
      "    def __init__(self, data: list|int) -> None:",
      "        if isinstance(data, int):",
      "            data = [0 for _ in range(data)]",
      "        self._n = len(data)",
      "        self._data = data",
      "        self._tree = [0] * (self._n + 1)",
      "        self.all_sum = self._build(data)",
      "    ",
      "    def _build(self, data: list) -> int:",
      "        \"\"\"treeを作成。すべての和を返す\"\"\"",
      "        cum = [0] * (self._n + 1)",
      "        for i in range(1, self._n+1):",
      "            cum[i] = cum[i-1] + data[i-1]",
      "            self._tree[i] = cum[i] - cum[i-(-i&i)]",
      "        return cum[-1]",
      "    ",
      "    def __len__(self) -> int:",
      "        \"\"\"データの大きさ\"\"\"",
      "        return self._n",
      "    ",
      "    def __getitem__(self, i: int) -> int:",
      "        \"\"\"i番目を取得\"\"\"",
      "        return self.get(i)",
      "    ",
      "    def __setitem__(self, i: int, x: int) -> None:",
      "        \"\"\"i番目をxにする\"\"\"",
      "        self.set(i, x)",
      "    ",
      "    def __iter__(self) -> Iterator[int]:",
      "        for i in range(self._n):",
      "            yield self.get(i)",
      "    ",
      "    def __repr__(self) -> str:",
      "        return f'FenwickTree {self._data}'",
      "    ",
      "    def get(self, i: int) -> int:",
      "        \"\"\"i番目を取得\"\"\"",
      "        assert 0 <= i < self._n, f\"index error i={i}\"",
      "        return self._data[i]",
      "    ",
      "    def add(self, i: int, x: int) -> None:",
      "        \"\"\"i番目にxを加える\"\"\"",
      "        assert 0 <= i < self._n, f\"index error i={i}\"",
      "        self._data[i] += x",
      "        self.all_sum += x",
      "        i += 1",
      "        while i <= self._n:",
      "            self._tree[i] += x",
      "            i += -i & i",
      "    ",
      "    def set(self, i: int, x: int) -> None:",
      "        \"\"\"i番目をxにする\"\"\"",
      "        assert 0 <= i < self._n, f\"index error i={i}\"",
      "        self.add(i, x - self._data[i])",
      "    ",
      "    def _sum(self, i: int) -> int:",
      "        \"\"\"区間[0, i)の和\"\"\"",
      "        sum = 0",
      "        while i > 0:",
      "            sum += self._tree[i]",
      "            i -= -i & i",
      "        return sum",
      "    ",
      "    def sum(self, l: int, r: int) -> int:",
      "        \"\"\"区間[l, r)の和\"\"\"",
      "        assert 0 <= l <= r <= self._n, f\"index error [l,r)=[{l},{r})\"",
      "        return self._sum(r) - self._sum(l)",
      "    ",
      "    def bisect_left(self, x: int) -> int:",
      "        \"\"\"区間[0, index)の和がx以上になる最小のindex\"\"\"",
      "        i = 1 << self._n.bit_length() - 1",
      "        value = 0",
      "        while not i & 1:",
      "            if i-1 < self._n and value + self._tree[i] < x:",
      "                value += self._tree[i]",
      "                i += (-i & i) >> 1",
      "            else:",
      "                i -= (-i & i) >> 1",
      "        return i-1 + (value + self._tree[i] < x)",
      "    ",
      "    def bisect_right(self, x: int) -> int:",
      "        \"\"\"区間[0, index)の和がx超過になる最小のindex\"\"\"",
      "        i = 1 << self._n.bit_length()-1",
      "        value = 0",
      "        while not i & 1:",
      "            if i-1 < self._n and value + self._tree[i] <= x:",
      "                value += self._tree[i]",
      "                i += (-i & i) >> 1",
      "            else:",
      "                i -= (-i & i) >> 1",
      "        return i-1 + (value + self._tree[i] <= x)"
    ],
    "description": "Auto snippet for FenwickTree"
  }
}