{
  "run_length_encode": {
    "prefix": "def run_length_encode",
    "body": [
      "def run_length_encode(a: str | list) -> list[tuple[object, int]]:",
      "    \"\"\"ランレングス圧縮\"\"\"",
      "    rle = []",
      "    l = r = 0",
      "    while l < len(a):",
      "        while r < len(a) and a[l] == a[r]:",
      "            r += 1",
      "        rle.append((a[l], r-l))",
      "        l = r",
      "    return rle"
    ],
    "description": "Auto snippet for run_length_encode"
  },
  "Compressor": {
    "prefix": "class Compressor",
    "body": [
      "from bisect import bisect_left",
      "",
      "class Compressor:",
      "    \"\"\"",
      "    座標圧縮",
      "",
      "    Methods:",
      "        original(compressed): 圧縮後の値 -> 元の値",
      "        compress(original)  : 元の値 -> 圧縮後の値",
      "    \"\"\"",
      "    def __init__(self, numbers: set) -> None:",
      "        self._numbers = sorted(set(numbers))",
      "        self._compressed = {v: i for i, v in enumerate(self._numbers)}",
      "    ",
      "    def __call__(self, original: int) -> int:",
      "        return self.compress(original)",
      "    ",
      "    def __repr__(self) -> str:",
      "        return f\"{self._compressed}\"",
      "",
      "    def original(self, compressed: int) -> int:",
      "        \"\"\"圧縮後の値から元の値を返す\"\"\"",
      "        return self._numbers[compressed]",
      "",
      "    def compress(self, original: int) -> int:",
      "        \"\"\"元の値から圧縮後の値を返す\"\"\"",
      "        if original not in self._compressed:",
      "            self._compressed[original] = bisect_left(self._numbers, original)",
      "        return self._compressed[original]"
    ],
    "description": "Auto snippet for Compressor"
  },
  "UnionFind": {
    "prefix": "class UnionFind",
    "body": [
      "class UnionFind:",
      "    \"\"\"",
      "    連結を管理するデータ構造。計算量はアッカーマン関数の逆関数",
      "    ",
      "    Attributes:\\n",
      "        element_list   : 初期化で生成した要素が入る",
      "        element_dict   : addによって追加したもの",
      "        component_count: 連結成分の個数",
      "    ",
      "    Methods:\\n",
      "        element(id) : idをElememt型で取得",
      "        contains(id): idが存在するか",
      "        add(id)     : 頂点idを追加",
      "        leader(v)   : vの属する連結成分の根",
      "        merge(u, v) : u, vを連結",
      "        same(u, v)  : u, vが連結か",
      "        size(v)     : vの属する連結成分の要素数",
      "        members(v)  : vの属する連結成分の要素",
      "        leaders     : すべてのleaderを列挙",
      "        groups      : すべてのleader, memberを列挙",
      "    \"\"\"",
      "",
      "    class Element:",
      "        \"\"\"追加でデータが必要なときは、ここに直接かく\"\"\"",
      "        def __init__(self, id: int) -> None:",
      "            self.id = id",
      "            self.parent = None",
      "            self.size = 1",
      "        ",
      "        def __repr__(self) -> str:",
      "            return f'{self.id}'",
      "        ",
      "        def merge(self, other: \"UnionFind.Element\") -> None:",
      "            \"\"\"selfにotherをmerge\"\"\"",
      "            other.parent = self",
      "            self.size += other.size",
      "        ",
      "        def should_parent(self, other: \"UnionFind.Element\") -> bool:",
      "            \"\"\"selfにotherをmergeするとき、こうなっていればok\"\"\"",
      "            return self.size > other.size",
      "    ",
      "    def __init__(self, n: int = 0) -> None:",
      "        self._n = n",
      "        self._component_count = n",
      "        self._element_list = [UnionFind.Element(i) for i in range(n)]",
      "        self._element_dict = {}",
      "    ",
      "    def __getitem__(self, id: object) -> Element:",
      "        \"\"\"頂点idをElement型で取得\"\"\"",
      "        return self.element(id)",
      "    ",
      "    def __contains__(self, id: object) -> bool:",
      "        \"\"\"idが存在するか\"\"\"",
      "        return self.contains(id)",
      "    ",
      "    def __repr__(self) -> str:",
      "        string = [\"UnionFind (\\n\"]",
      "        for leader, members in self.groups.items():",
      "            string.append(f'  leader={leader}, members={members}\\n')",
      "        string.append(\")\")",
      "        return ''.join(string)",
      "    ",
      "    def element(self, id: object) -> Element:",
      "        \"\"\"頂点idをElement型で取得\"\"\"",
      "        assert id in self, f\"id={id} does not exist\"",
      "        if self._in_element_list(id):",
      "            return self._element_list[id]",
      "        return self._element_dict[id]",
      "    ",
      "    def contains(self, id: object) -> bool:",
      "        \"\"\"idが存在するか\"\"\"",
      "        if self._in_element_list(id):",
      "            return True",
      "        return id in self._element_dict",
      "    ",
      "    def add(self, id: object) -> None:",
      "        \"\"\"頂点idを追加。int型でもdictのほうに追加される\"\"\"",
      "        assert id not in self, f\"id={id} already exists\"",
      "        self._element_dict[id] = UnionFind.Element(id)",
      "        self._n += 1",
      "        self._component_count += 1",
      "    ",
      "    def leader(self, id: object) -> object:",
      "        \"\"\"vの属する連結成分の根\"\"\"",
      "        v = self.element(id)",
      "        if v.parent:",
      "            stack = []",
      "            while v.parent:",
      "                stack.append(v)",
      "                v = v.parent",
      "            while stack:",
      "                stack.pop().parent = v",
      "        return v.id",
      "    ",
      "    def merge(self, u: object, v: object) -> bool:",
      "        \"\"\"u, vを連結\"\"\"",
      "        ru = self.element(self.leader(u))",
      "        rv = self.element(self.leader(v))",
      "        if ru == rv: #すでに連結なら",
      "            return False",
      "        self._component_count -= 1",
      "        if not ru.should_parent(rv):",
      "            ru, rv = rv, ru",
      "        ru.merge(rv) #ruにrvをmerge",
      "        return True",
      "    ",
      "    def same(self, u: object, v: object) -> bool:",
      "        \"\"\"u, vが連結か\"\"\"",
      "        return self.leader(u) == self.leader(v)",
      "    ",
      "    def size(self, v: object) -> int:",
      "        \"\"\"vの連結成分の要素数\"\"\"",
      "        return self.element(self.leader(v)).size",
      "    ",
      "    def members(self, v: object) -> list[object]:",
      "        \"\"\"vの連結成分の要素を列挙\"\"\"",
      "        rv = self.leader(v)",
      "        members = []",
      "        members.extend([i for i, v in enumerate(self._element_list) if self.leader(i) ==  rv])",
      "        members.extend([i for i, v in self._element_dict.items() if self.leader(i) == rv])",
      "        return members",
      "    ",
      "    def _in_element_list(self, id: object) -> bool:",
      "        \"\"\"idが初期のやつか\"\"\"",
      "        return isinstance(id, int) and 0 <= id < len(self._element_list)",
      "    ",
      "    @property",
      "    def component_count(self) -> int:",
      "        \"\"\"連結成分の個数\"\"\"",
      "        return self._component_count",
      "    ",
      "    @property",
      "    def leaders(self) -> list[object]:",
      "        \"\"\"leaderを列挙\"\"\"",
      "        leaders = []",
      "        leaders.extend([i for i, v in enumerate(self._element_list) if v.parent is None])",
      "        leaders.extend([i for i, v in self._element_dict.items() if v.parent is None])",
      "        return leaders",
      "    ",
      "    @property",
      "    def groups(self) -> dict[object, list[object]]:",
      "        \"\"\"すべてのleaderとmembersを列挙\"\"\"",
      "        group = {}",
      "        for i, v in enumerate(self._element_list):",
      "            group.setdefault(self.leader(i), []).append(i)",
      "        for i, v in self._element_dict.items():",
      "            group.setdefault(self.leader(i), []).append(i)",
      "        return group"
    ],
    "description": "Auto snippet for UnionFind"
  },
  "Graph": {
    "prefix": "class Graph",
    "body": [
      "class Graph:",
      "    \"\"\"",
      "    CSR形式",
      "    buildを手動で呼び出す必要がある",
      "",
      "    Attributes:",
      "        n    : 頂点数",
      "        m    : 辺数",
      "        edges: 辺(u,v,w)",
      "        子クラスからも参照するからpublic",
      "    ",
      "    Methods:",
      "        build()                 : CSRの配列をつくる",
      "        add_edge(u, v, w=1)     : u -> v に重み w の 有向辺 を張る",
      "        edge(i)                 : i番目の辺",
      "        neighbors(v)            : 隣接頂点 __getitem__ に割り当て",
      "        neighbors_with_weight(v): 重み付き隣接頂点 __call__ に割り当て",
      "    \"\"\"",
      "    def __init__(self, n: int, m: int) -> None:",
      "        self.n = n",
      "        self.m = m",
      "        self.edges: list[tuple[int, int, int]] = []",
      "        self._ptr = [0] * (n+1)",
      "        self._adj: list[int] | None = None",
      "        self._weight: list[int] | None = None",
      "    ",
      "    def __len__(self) -> int:",
      "        \"\"\"頂点数\"\"\"",
      "        return self.n",
      "    ",
      "    def __getitem__(self, v: int) -> list[int]:",
      "        \"\"\"vに隣接する頂点のリスト\"\"\"",
      "        return self.neighbors(v)",
      "    ",
      "    def __call__(self, v: int) -> list[tuple[int, int]]:",
      "        \"\"\"vに隣接する頂点のリスト（重み付き）\"\"\"",
      "        return self.neighbors_with_weight(v)",
      "    ",
      "    def build(self) -> None:",
      "        \"\"\"グラフを作成\"\"\"",
      "        self._adj = [0] * len(self.edges)",
      "        self._weight = [0] * len(self.edges)",
      "        for i in range(self.n):",
      "            self._ptr[i+1] += self._ptr[i]",
      "        for u, v, w in self.edges:",
      "            self._ptr[u] -= 1",
      "            self._adj[self._ptr[u]] = v",
      "            self._weight[self._ptr[u]] = w",
      "    ",
      "    def add_edge(self, u: int, v: int, w: int = 1) -> int:",
      "        \"\"\"u -> v に重み w の 有向辺 を張る\"\"\"",
      "        assert 0 <= u < self.n, f\"u={u} is out of range\"",
      "        assert 0 <= v < self.n, f\"v={v} is out of range\"",
      "        self.edges.append((u, v, w))",
      "        self._ptr[u] += 1",
      "        return len(self.edges) - 1",
      "    ",
      "    def edge(self, i: int) -> tuple[int, int, int]:",
      "        \"\"\"辺i\"\"\"",
      "        assert 0 <= i < len(self.edges), f\"i={i} is out of range\"",
      "        return self.edges[i]",
      "    ",
      "    def neighbors(self, v: int) -> list[int]:",
      "        \"\"\"vに隣接する頂点のリスト\"\"\"",
      "        assert self._adj, \"build() is not called\"",
      "        return self._adj[self._ptr[v]: self._ptr[v+1]]",
      "    ",
      "    def neighbors_with_weight(self, v: int) -> list[tuple[int, int]]:",
      "        \"\"\"v に隣接する頂点のリスト（重み付き）\"\"\"",
      "        assert self._adj, \"build() is not called\"",
      "        return list(zip(",
      "            self._adj[self._ptr[v]: self._ptr[v+1]],",
      "            self._weight[self._ptr[v]: self._ptr[v+1]]",
      "        ))",
      "    "
    ],
    "description": "Auto snippet for Graph"
  },
  "bfs": {
    "prefix": "def bfs",
    "body": [
      "from collections import deque",
      "",
      "def bfs(graph: Graph, starts: list[int]) -> None:",
      "    dq = deque([(v, 0) for v in starts])",
      "    visited = [False] * graph.n",
      "    while dq:",
      "        u, d = dq.popleft()",
      "        if visited[u]:",
      "            continue",
      "        visited[u] = True",
      "        for v in graph[u]:",
      "            if not visited[v]:",
      "                dq.append((v, d+1))"
    ],
    "description": "Auto snippet for bfs"
  },
  "enumerate_divisors": {
    "prefix": "def enumerate_divisors",
    "body": [
      "def enumerate_divisors(n: int) -> list[int]:",
      "    \"\"\"nの約数を昇順に列挙\"\"\"",
      "    lower_divisors = []",
      "    upper_divisors = []",
      "    i = 1",
      "    while i * i <= n:",
      "        if n % i == 0:",
      "            lower_divisors.append(i)",
      "            if i != n // i:",
      "                upper_divisors.append(n // i)",
      "        i += 1",
      "    return lower_divisors + upper_divisors[::-1]",
      "",
      "",
      "def enumerate_divisors_from_factor(prime_factor: dict[int, int]) -> list[int]:",
      "    \"\"\"素因数から約数を列挙\"\"\"",
      "    divisors = [1]",
      "    for radix, exp in prime_factor.items():",
      "        for d in divisors[:]: #appendしていくのでコピーから取り出している",
      "            val = 1",
      "            for _ in range(exp):",
      "                val *= radix",
      "                divisors.append(d * val)",
      "    return sorted(divisors)"
    ],
    "description": "Auto snippet for enumerate_divisors"
  },
  "Binomial": {
    "prefix": "class Binomial",
    "body": [
      "class Binomial:",
      "    \"\"\"",
      "    二項係数 Mod",
      "",
      "    Methods:",
      "        fact(n)                          : n!",
      "        ifact(n)                         : n! ^ -1",
      "        permutation(n, r)                : nPr",
      "        permutation_with_repetition(n, r): n^r",
      "        combination(n, r)                : nCr",
      "        combination_with_repetition(n, r): nHr",
      "        multiset_permutation(frequencies): aabbbccccのような順列",
      "    \"\"\"",
      "    def __init__(self, n: int, mod: int) -> None:",
      "        \"\"\"n: n!まで計算できる\"\"\"",
      "        fact = [1 for _ in range(n+1)]",
      "        ifact = [1 for _ in range(n+1)]",
      "        for i in range(1, n+1):",
      "            fact[i] = fact[i-1] * i % mod",
      "        ifact[n] = pow(fact[n], mod-2, mod)",
      "        for i in range(n-1, -1, -1):",
      "            ifact[i] = ifact[i+1] * (i+1) % mod",
      "",
      "        self._fact = fact",
      "        self._ifact = ifact",
      "        self._mod = mod",
      "        self._n = n",
      "    ",
      "    def fact(self, n: int) -> int:",
      "        \"\"\"n!\"\"\"",
      "        assert 0 <= n <= self._n, f\"Value error: n={n}\"",
      "        return self._fact[n]",
      "    ",
      "    def ifact(self, n: int) -> int:",
      "        \"\"\"n!^(-1)\"\"\"",
      "        assert 0 <= n <= self._n, f\"Value error: n={n}\"",
      "        return self._ifact[n]",
      "",
      "    def permutation(self, n: int, r: int) -> int:",
      "        \"\"\"n個の中からr個選んで並べる順列の数\"\"\"",
      "        assert n <= self._n, f\"Value error: (n,r)=({n},{r})\"",
      "        if n < r or r < 0:",
      "            return 0",
      "        return self._fact[n] * self._ifact[n-r] % self._mod",
      "    ",
      "    def permutation_with_repetition(self, n: int, r: int) -> int:",
      "        \"\"\"n個の中からr個 重複を許して並べる順列の個数\"\"\"",
      "        if r < 0:",
      "            return 0",
      "        return pow(n, r, self._mod)",
      "",
      "    def combination(self, n: int, r: int) -> int:",
      "        \"\"\"n個の中からr個選ぶ組み合わせの数\"\"\"",
      "        assert n <= self._n, f\"Value error: n={n}\"",
      "        if n < r or r < 0:",
      "            return 0",
      "        return self._fact[n] * self._ifact[r] * self._ifact[n-r] % self._mod",
      "    ",
      "    def combination_with_repetition(self, n: int, r: int) -> int:",
      "        \"\"\"重複組み合わせ\"\"\"",
      "        assert n+r-1 <= self._n, f\"Value error: n+r-1={n+r-1}\"",
      "        return self.combination(n+r-1, r)",
      "    ",
      "    def multiset_permutation(self, frequencies: list[int]) -> int:",
      "        \"\"\"aabbbccccのような順列\"\"\"",
      "        assert sum(frequencies) <= self._n, f\"Value error: sum(frequencies)={sum(frequencies)}\"",
      "        res = self._fact[sum(frequencies)]",
      "        for i in frequencies:",
      "            res = (res * self._ifact[i]) % self._mod",
      "        return res"
    ],
    "description": "Auto snippet for Binomial"
  },
  "Ring": {
    "prefix": "class Ring",
    "body": [
      "class Ring:",
      "    \"\"\"",
      "    円環上の道のりを計算する",
      "    周期nで 0~n-1",
      "    forward  : 数字が増える方向",
      "    backward : 数字が減る方向",
      "",
      "    Methods:",
      "        forward_cost     : forwardに進んだ場合の道のり",
      "        backward_cost    : backwardに進んだ場合の道のり",
      "        via_cost         : startからendまで、pointを通るほうのコスト",
      "        avoid_cost       : startからendまで、pointを避けるほうのコスト",
      "        on_forward_path  : forwardのstartからendまでの間にpointが存在するか",
      "        on_backward_path : backwardのstartからendまでの間にpointが存在するか",
      "        mid_point        : a,bの中点(2つ)を返す。(n,a,b)=(3,1,2) -> 1.5, 0",
      "    \"\"\"",
      "    def __init__(self, n: int) -> None:",
      "        self.n = n",
      "    ",
      "    def forward_cost(self, start: int, end: int) -> int:",
      "        \"\"\"forwardに進んだ場合の道のり\"\"\"",
      "        return (end - start) % self.n",
      "    ",
      "    def backward_cost(self, start: int, end: int) -> int:",
      "        \"\"\"backwardに進んだ場合の道のり\"\"\"",
      "        return (start - end) % self.n",
      "    ",
      "    def via_cost(self, start: int, end: int, point: int) -> int:",
      "        \"\"\"startからendまで、pointを通るほうのコスト\"\"\"",
      "        if self.on_forward_path(start, end, point):",
      "            return self.forward_cost(start, end)",
      "        return self.backward_cost(start, end)",
      "    ",
      "    def avoid_cost(self, start: int, end: int, point: int) -> int:",
      "        \"\"\"startからendまで、pointを避けるほうのコスト\"\"\"",
      "        if self.on_backward_path(start, end, point):",
      "            return self.forward_cost(start, end)",
      "        return self.backward_cost(start, end)",
      "    ",
      "    def on_forward_path(self, start: int, end: int, point: int, inclusive: bool = False) -> bool:",
      "        \"\"\"forwardのstartからendまでの間にpointが存在するか\"\"\"",
      "        start, end, point = self._mod(start, end, point)",
      "        if inclusive: #start と end も含めるなら",
      "            return (point - start) * (start - end) * (end - point) <= 0",
      "        return (point - start) * (start - end) * (end - point) < 0",
      "    ",
      "    def on_backward_path(self, start: int, end: int, point: int, inclusive: bool = False) -> bool:",
      "        \"\"\"backwardのstartからendまでの間にpointが存在するか\"\"\"",
      "        start, end, point = self._mod(start, end, point)",
      "        if inclusive: #start と end も含めるなら",
      "            return (point - start) * (start - end) * (end - point) >= 0",
      "        return (point - start) * (start - end) * (end - point) > 0",
      "    ",
      "    def mid_point(self, a: int, b: int) -> float:",
      "        \"\"\"a,bの中点(2つ)を返す。(n,a,b)=(3,1,2) -> 1.5, 0\"\"\"",
      "        p1 = ((a + b) / 2) % self.n",
      "        p2 = ((a + b + self.n) / 2) % self.n",
      "        return p1, p2",
      "    ",
      "    def _mod(self, *val):",
      "        return map(lambda x: int(x) % self.n, val)"
    ],
    "description": "Auto snippet for Ring"
  },
  "FenwickTree": {
    "prefix": "class FenwickTree",
    "body": [
      "from typing import Iterator",
      "",
      "class FenwickTree:",
      "    \"\"\"",
      "    区間の和を O(log n) で計算",
      "",
      "    Methods:\\n",
      "        get(i)         : i番目を取得",
      "        set(i, x)      : i番目をxにする",
      "        add(i, x)      : i番目にxを加算",
      "        sum(l, r)      : 区間[l, r)の和",
      "        bisect_left(x) : 累積和配列とみなし、二分探索",
      "        bisect_right(x): 累積和配列とみなし、二分探索",
      "    \"\"\"",
      "",
      "    def __init__(self, data: list|int) -> None:",
      "        if isinstance(data, int):",
      "            data = [0 for _ in range(data)]",
      "        self._n = len(data)",
      "        self._data = data",
      "        self._tree = [0] * (self._n + 1)",
      "        self.all_sum = self._build(data)",
      "    ",
      "    def _build(self, data: list) -> int:",
      "        \"\"\"treeを作成。すべての和を返す\"\"\"",
      "        cum = [0] * (self._n + 1)",
      "        for i in range(1, self._n+1):",
      "            cum[i] = cum[i-1] + data[i-1]",
      "            self._tree[i] = cum[i] - cum[i-(-i&i)]",
      "        return cum[-1]",
      "    ",
      "    def __len__(self) -> int:",
      "        \"\"\"データの大きさ\"\"\"",
      "        return self._n",
      "    ",
      "    def __getitem__(self, i: int) -> int:",
      "        \"\"\"i番目を取得\"\"\"",
      "        return self.get(i)",
      "    ",
      "    def __setitem__(self, i: int, x: int) -> None:",
      "        \"\"\"i番目をxにする\"\"\"",
      "        self.set(i, x)",
      "    ",
      "    def __iter__(self) -> Iterator[int]:",
      "        for i in range(self._n):",
      "            yield self.get(i)",
      "    ",
      "    def __repr__(self) -> str:",
      "        return f'FenwickTree {self._data}'",
      "    ",
      "    def get(self, i: int) -> int:",
      "        \"\"\"i番目を取得\"\"\"",
      "        assert 0 <= i < self._n, f\"index error i={i}\"",
      "        return self._data[i]",
      "    ",
      "    def add(self, i: int, x: int) -> None:",
      "        \"\"\"i番目にxを加える\"\"\"",
      "        assert 0 <= i < self._n, f\"index error i={i}\"",
      "        self._data[i] += x",
      "        self.all_sum += x",
      "        i += 1",
      "        while i <= self._n:",
      "            self._tree[i] += x",
      "            i += -i & i",
      "    ",
      "    def set(self, i: int, x: int) -> None:",
      "        \"\"\"i番目をxにする\"\"\"",
      "        assert 0 <= i < self._n, f\"index error i={i}\"",
      "        self.add(i, x - self._data[i])",
      "    ",
      "    def _sum(self, i: int) -> int:",
      "        \"\"\"区間[0, i)の和\"\"\"",
      "        sum = 0",
      "        while i > 0:",
      "            sum += self._tree[i]",
      "            i -= -i & i",
      "        return sum",
      "    ",
      "    def sum(self, l: int, r: int) -> int:",
      "        \"\"\"区間[l, r)の和\"\"\"",
      "        assert 0 <= l <= r <= self._n, f\"index error [l,r)=[{l},{r})\"",
      "        return self._sum(r) - self._sum(l)",
      "    ",
      "    def bisect_left(self, x: int) -> int:",
      "        \"\"\"区間[0, index)の和がx以上になる最小のindex\"\"\"",
      "        i = 1 << self._n.bit_length() - 1",
      "        value = 0",
      "        while not i & 1:",
      "            if i-1 < self._n and value + self._tree[i] < x:",
      "                value += self._tree[i]",
      "                i += (-i & i) >> 1",
      "            else:",
      "                i -= (-i & i) >> 1",
      "        return i-1 + (value + self._tree[i] < x)",
      "    ",
      "    def bisect_right(self, x: int) -> int:",
      "        \"\"\"区間[0, index)の和がx超過になる最小のindex\"\"\"",
      "        i = 1 << self._n.bit_length()-1",
      "        value = 0",
      "        while not i & 1:",
      "            if i-1 < self._n and value + self._tree[i] <= x:",
      "                value += self._tree[i]",
      "                i += (-i & i) >> 1",
      "            else:",
      "                i -= (-i & i) >> 1",
      "        return i-1 + (value + self._tree[i] <= x)"
    ],
    "description": "Auto snippet for FenwickTree"
  },
  "SegmentTree": {
    "prefix": "class SegmentTree",
    "body": [
      "from typing import Generic, TypeVar, Callable, Iterator",
      "",
      "Monoid = TypeVar(\"Monoid\")",
      "",
      "class SegmentTree(Generic[Monoid]):",
      "    \"\"\"",
      "    一点更新、区間取得を O(log n) で計算",
      "",
      "    Attributes:",
      "        op(x, y): xとyの二項演算（関数型）",
      "        e       : opの単位元",
      "",
      "    Methods:",
      "        get(i)    : i番目を取得",
      "        set(i, x) : i番目をxにする",
      "        prod(i, x): 区間[l, r)の積",
      "        all_prod(): 全体の積    ",
      "        max_right(l, condition): condition(prod[l,j))が真になる最大のjを返す",
      "        min_left(r, condition) : condition(prod[j,r))が真になる最小のjを返す",
      "    \"\"\"",
      "    ",
      "    def __init__(",
      "        self,",
      "        op: Callable[[Monoid, Monoid], Monoid],",
      "        e: Monoid,",
      "        data: list[Monoid] | int",
      "    ) -> None:",
      "        if isinstance(data, int):",
      "            data = [e for _ in range(data)]",
      "        self._n = len(data)",
      "        self._op = op",
      "        self._e = e",
      "        self._size = 1 << (len(data)-1).bit_length() # 最下段の長さ",
      "        self._tree = [e for _ in range(self._size*2)] # tree[1]が最上段,tree[size]が元のdata[0]",
      "        self._build(data)",
      "    ",
      "    def _build(self, data: list[Monoid]) -> None:",
      "        for i, val in enumerate(data):",
      "            self._tree[i+self._size] = val",
      "        for i in range(self._size-1, 0, -1):",
      "            self._update(i)",
      "    ",
      "    def __len__(self) -> int:",
      "        return self._n",
      "    ",
      "    def __getitem__(self, i: int) -> Monoid:",
      "        \"\"\"i番目を取得\"\"\"",
      "        return self.get(i)",
      "    ",
      "    def __setitem__(self, i: int, x: Monoid) -> None:",
      "        \"\"\"i番目にxを代入\"\"\"",
      "        self.set(i, x)",
      "",
      "    def __iter__(self) -> Iterator[Monoid]:",
      "        for i in range(self._n):",
      "            yield self.get(i)",
      "    ",
      "    def __repr__(self) -> str:",
      "        return f'SegmentTree {list(self)}'",
      "    ",
      "    def get(self, i: int) -> Monoid:",
      "        \"\"\"i番目を取得\"\"\"",
      "        assert 0 <= i < self._n, f\"index error i={i}\"",
      "        return self._tree[i+self._size]",
      "    ",
      "    def set(self, i: int, x: Monoid) -> None:",
      "        \"\"\"i番目にxを代入\"\"\"",
      "        assert 0 <= i < self._n, f\"index error i={i}\"",
      "        i += self._size",
      "        self._tree[i] = x",
      "        while i:",
      "            i >>= 1",
      "            self._update(i)",
      "    ",
      "    def prod(self, l: int, r: int) -> Monoid:",
      "        \"\"\"区間[l, r)の積\"\"\"",
      "        assert 0 <= l <= r <= self._n, f\"index error [l,r)=[{l},{r})\"",
      "        lt, rt = self._e, self._e",
      "        l += self._size",
      "        r += self._size",
      "        while l < r:",
      "            if l & 1: #右側だけなら",
      "                lt = self._op(lt, self._tree[l])",
      "                l += 1 #上は範囲外も含むから一つ右にずらす",
      "            if r & 1: #左側だけなら",
      "                r -= 1",
      "                rt = self._op(self._tree[r], rt)",
      "            l >>= 1",
      "            r >>= 1",
      "        return self._op(lt, rt)",
      "    ",
      "    def all_prod(self) -> Monoid:",
      "        \"\"\"全体の積\"\"\"",
      "        return self._tree[1]",
      "    ",
      "    def max_right(self, l: int, condition: Callable[[Monoid], bool]) -> int:",
      "        \"\"\"condition(prod[l,j))が真になる最大のjを返す\"\"\"",
      "        assert 0 <= l <= self._n, f\"index error l={l}\"",
      "        if l == self._n:",
      "            return self._n",
      "        ",
      "        l += self._size",
      "        val = self._e #確定した区間の積",
      "        while True:",
      "            while not l & 1: #右ノードになるまで親に移動",
      "                l >>= 1",
      "            if not condition(self._op(val, self._tree[l])):",
      "                while l < self._size: #下まで",
      "                    l <<= 1 #左の子に移動",
      "                    if condition(self._op(val, self._tree[l])): #満たすなら",
      "                        val = self._op(val, self._tree[l]) #左は確定して",
      "                        l += 1 #同じ段の右ノードに移動",
      "                return l - self._size",
      "            val = self._op(val, self._tree[l]) #満たすなら確定する",
      "            l += 1 #右に移動",
      "            if l & -l == l: #condition(prod(l,n)) = Trueなら(lが2の累乗)",
      "                return self._n #一番右を返す",
      "        ",
      "    def min_left(self, r: int, condition: Callable[[Monoid], bool]) -> int:",
      "        \"\"\"condition(prod[j,r))が真になる最小のjを返す\"\"\"",
      "        assert 0 <= r <= self._n, f\"index error r={r}\"",
      "        if r == 0:",
      "            return 0",
      "        ",
      "        r += self._size",
      "        val = self._e",
      "        while True:",
      "            while not r & 1:",
      "                r >>= 1",
      "            if not condition(self._op(val, self._tree[r-1])):",
      "                while r < self._size:",
      "                    r <<= 1",
      "                    if condition(self._op(val, self._tree[r-1])):",
      "                        r -= 1",
      "                        val = self._op(val, self._tree[r])",
      "                return r - self._size",
      "            r -= 1",
      "            val = self._op(val, self._tree[r])",
      "            if r & -r == r:",
      "                return 0",
      "    ",
      "    def _update(self, i: int) -> None:",
      "        self._tree[i] = self._op(self._tree[2*i], self._tree[2*i+1])",
      ""
    ],
    "description": "Auto snippet for SegmentTree"
  },
  "LazySegmentTree": {
    "prefix": "class LazySegmentTree",
    "body": [
      "from typing import Generic, TypeVar, Callable, Iterator",
      "",
      "Monoid = TypeVar(\"Monoid\")",
      "Operator = TypeVar(\"Operator\")",
      "",
      "class LazySegmentTree(Generic[Monoid, Operator]):",
      "    \"\"\"",
      "    区間作用、区間取得を O(log n) で計算",
      "",
      "    Attributes:",
      "        op(x,y)         : 二項演算",
      "        e               : 単位元",
      "        mapping(f,x)    : 作用 xにfを作用",
      "        composition(g,f): 合成 g*f gが後の操作",
      "        id              : 恒等写像",
      "",
      "    Methods:",
      "        get(i)        : i番目を取得",
      "        set(i, x)     : i番目をxにする",
      "        apply(l, r, f): 区間[l,r)にfを作用",
      "        prod(i, x)    : 区間[l, r)の積",
      "        all_prod()    : 全体の積    ",
      "        max_right(l, condition): condition(prod[l,j))が真になる最大のjを返す",
      "        min_left(r, condition) : condition(prod[j,r))が真になる最小のjを返す",
      "    \"\"\"",
      "    def __init__(",
      "        self,",
      "        op: Callable[[Monoid, Monoid], Monoid],",
      "        e: Monoid,",
      "        mapping: Callable[[Operator, Monoid], Monoid],",
      "        composition: Callable[[Operator, Operator], Operator],",
      "        id: Operator,",
      "        data: list[Monoid] | int",
      "    ) -> None:",
      "        if isinstance(data, int):",
      "            data = [e for _ in range(data)]",
      "        self._n = len(data)",
      "        self._op = op",
      "        self._e = e",
      "        self._mapping = mapping",
      "        self._composition = composition",
      "        self._id = id",
      "        self._log = (len(data)-1).bit_length()",
      "        self._size = 1 << self._log",
      "        self._tree = [e for _ in range(self._size*2)]",
      "        self._lazy = [id for _ in range(self._size*2)]",
      "        self._build(data)",
      "    ",
      "    def _build(self, data: list[Monoid]) -> None:",
      "        for i,val in enumerate(data):",
      "            self._tree[i+self._size] = val",
      "        for i in range(self._size-1, 0, -1):",
      "            self._update(i)",
      "    ",
      "    def __len__(self) -> int:",
      "        return self._n",
      "",
      "    def __getitem__(self, i: int) -> Monoid:",
      "        return self.get(i)",
      "    ",
      "    def __setitem__(self, i: int, x: Monoid) -> None:",
      "        self.set(i, x)",
      "    ",
      "    def __iter__(self) -> Iterator[Monoid]:",
      "        for i in range(self._n):",
      "            yield self.get(i)",
      "    ",
      "    def __repr__(self) -> str:",
      "        return f'LazySegmentTree {list(self)}'",
      "    ",
      "    def get(self, p: int) -> Monoid:",
      "        assert 0 <= p < self._n, f\"index error p={p}\"",
      "        p += self._size",
      "        for i in range(self._log, 0, -1): #lazyを上から伝播させて",
      "            self._push(p >> i)",
      "        return self._tree[p]",
      "    ",
      "    def set(self, p: int, x: Monoid) -> None:",
      "        assert 0 <= p < self._n, f\"index error p={p}\"",
      "        p += self._size",
      "        for i in range(self._log, 0, -1): #lazyを上から伝播させて",
      "            self._push(p >> i)",
      "        self._tree[p] = x",
      "        while p: #普通のセグ木と同じように更新",
      "            p >>= 1",
      "            self._update(p)",
      "    ",
      "    def prod(self, l: int, r: int) -> Monoid:",
      "        \"\"\"区間[l, r)の積\"\"\"",
      "        assert 0 <= l <= r <= self._n, f\"index error [l,r)=[{l},{r})\"",
      "        if l == r:",
      "            return self._e",
      "        l += self._size",
      "        r += self._size",
      "        for i in range(self._log, 0, -1): #必要な部分のlazyを伝播",
      "            if ((l >> i) << i) != l:",
      "                self._push(l >> i)",
      "            if ((r >> i) << i) != r:",
      "                self._push(r-1 >> i)",
      "        lt = self._e",
      "        rt = self._e",
      "        while l < r:",
      "            if l & 1:#右側だけなら",
      "                lt = self._op(lt, self._tree[l])",
      "                l += 1 #上は範囲外も含むから一つ右にずらす",
      "            if r & 1:#左側だけなら",
      "                r -= 1",
      "                rt = self._op(self._tree[r], rt)",
      "            l >>= 1",
      "            r >>= 1",
      "        return self._op(lt, rt)",
      "    ",
      "    def all_prod(self) -> Monoid:",
      "        return self._tree[1]",
      "    ",
      "    def apply(self, l: int, r: int, f: Operator) -> None:",
      "        \"\"\"区間[l, r)にfを作用\"\"\"",
      "        assert 0 <= l <= r <= self._n, f\"index error [l,r)=[{l},{r})\"",
      "        if l == r:",
      "            return",
      "        l += self._size",
      "        r += self._size",
      "        for i in range(self._log, 0, -1):",
      "            if ((l >> i) << i) != l:",
      "                self._push(l >> i)",
      "            if ((r >> i) << i) != r:",
      "                self._push(r-1 >> i)",
      "        ",
      "        tmp_l = l",
      "        tmp_r = r",
      "        while l < r:",
      "            if l & 1:",
      "                self._all_apply(l, f)",
      "                l += 1",
      "            if r & 1:",
      "                r -= 1",
      "                self._all_apply(r, f)",
      "            l >>= 1",
      "            r >>= 1",
      "        ",
      "        l = tmp_l",
      "        r = tmp_r",
      "        for i in range(1, self._log+1):",
      "            if ((l >> i) << i) != l:",
      "                self._update(l >> i)",
      "            if ((r >> i) << i) != r:",
      "                self._update(r-1 >> i)",
      "    ",
      "    def max_right(self, l: int, condition: Callable[[Monoid], bool]) -> int:",
      "        \"\"\"condition(prod[l,j))が真になる最大のjを返す\"\"\"",
      "        assert 0 <= l <= self._n, f\"index error l={l}\"",
      "        if l == self._n:",
      "            return self._n",
      "        ",
      "        l += self._size",
      "        #上に移動するときに見るところのlazyを伝播",
      "        for i in range(self._log, 0, -1):",
      "            self._push(l >> i)",
      "        ",
      "        val = self._e",
      "        while True:",
      "            while not l & 1:",
      "                l >>= 1",
      "            if not condition(self._op(val, self._tree[l])):",
      "                while l < self._size:",
      "                    self._push(l)#右側は伝播できてないのでする",
      "                    l <<= 1",
      "                    if condition(self._op(val, self._tree[l])):",
      "                        val = self._op(val, self._tree[l])",
      "                        l += 1",
      "                return l - self._size",
      "            val = self._op(val, self._tree[l])",
      "            l += 1",
      "            if l & -l == l:",
      "                return self._n",
      "    ",
      "    def min_left(self, r: int, condition: Callable[[Monoid], bool]) -> int:",
      "        \"\"\"condition(prod[j,r))が真になる最小のjを返す\"\"\"",
      "        assert 0 <= r <= self._n, f\"index error r={r}\"",
      "        if r == 0:",
      "            return 0",
      "        ",
      "        r += self._size",
      "        for i in range(self._log, 0, -1):",
      "            self._push((r-1) >> i)",
      "        ",
      "        val = self._e",
      "        while True:",
      "            while not r & 1:",
      "                r >>= 1",
      "            if not condition(self._op(val, self._tree[r-1])):",
      "                while r < self._size:",
      "                    self._push(r-1)",
      "                    r <<= 1",
      "                    if condition(self._op(val, self._tree[r-1])):",
      "                        r -= 1",
      "                        val = self._op(val, self._tree[r])",
      "                return r - self._size",
      "            r -= 1",
      "            val = self._op(val, self._tree[r])",
      "            if r & -r == r:",
      "                return 0",
      "            ",
      "    def _update(self, i: int) -> None:",
      "        \"\"\"tree[i]を更新\"\"\"",
      "        self._tree[i] = self._op(self._tree[2*i], self._tree[2*i+1])",
      "    ",
      "    def _all_apply(self, i: int, f: Operator) -> None:",
      "        \"\"\"tree[i],lazy[i]にfを作用\"\"\"",
      "        self._tree[i] = self._mapping(f, self._tree[i])",
      "        if i < self._size:",
      "            self._lazy[i] = self._composition(f, self._lazy[i])",
      "    ",
      "    def _push(self, i: int) -> None:",
      "        \"\"\"１つ下に伝播\"\"\"",
      "        self._all_apply(2*i, self._lazy[i])",
      "        self._all_apply(2*i+1, self._lazy[i])",
      "        self._lazy[i] = self._id"
    ],
    "description": "Auto snippet for LazySegmentTree"
  },
  "binary_search": {
    "prefix": "def binary_search",
    "body": [
      "def binary_search(ok: int, ng: int, *args) -> int:",
      "    \"\"\"二分探索\"\"\"",
      "    def satisfies(x: int) -> bool:",
      "        \"\"\"xのとき条件を満たすか\"\"\"",
      "        return",
      "    ",
      "    ng += 1 if ok < ng else -1",
      "    while abs(ok - ng) > 1:",
      "        mid = (ok + ng) // 2",
      "        if satisfies(mid):",
      "            ok = mid",
      "        else:",
      "            ng = mid",
      "    return ok"
    ],
    "description": "Auto snippet for binary_search"
  },
  "RollingHash": {
    "prefix": "class RollingHash",
    "body": [
      "import random",
      "",
      "class RollingHash:",
      "    \"\"\"",
      "    hashを比較することで文字の一致判定",
      "",
      "    Methods:",
      "        hash(l, r)         : [l, r)のhash。__call__でも呼べる",
      "        join(sh, th)       : s,tをこの順に結合した文字列のhash値",
      "        is_palindrome(l, r): [l, r)が回文か",
      "        make_reverse()     : 逆向きのインスタンスを生成",
      "    \"\"\"",
      "",
      "    MOD = (1 << 61) - 1",
      "    MASK30 = (1 << 30) - 1",
      "    MASK31 = (1 << 31) - 1",
      "    MASK61 = MOD",
      "    base = None",
      "    base_pow = [1]",
      "",
      "    def __init__(self, string: str) -> None:",
      "        self.string = string",
      "        if RollingHash.base is None:",
      "            RollingHash.base = random.randrange(1 << 31, RollingHash.MOD)",
      "        if len(RollingHash.base_pow) <= len(string):",
      "            self._make_base_pow(len(string))",
      "        self._hash = [1]",
      "        for char in string:",
      "            self._hash.append(self._calc_mod(self._mul(self._hash[-1], RollingHash.base) + ord(char)))",
      "    ",
      "    def __len__(self) -> int:",
      "        return len(self.string)",
      "    ",
      "    def __getitem__(self, i: int) -> str:",
      "        return self.string[i]",
      "    ",
      "    def __call__(self, l: int, r: int) -> int:",
      "        \"\"\"[l,r)のhash\"\"\"",
      "        return self.hash(l, r)",
      "    ",
      "    def hash(self, l: int, r: int) -> int:",
      "        \"\"\"[l,r)のhash\"\"\"",
      "        assert 0 <= l <= r <= len(self), f\"index error [l,r)=[{l},{r})\"",
      "        res = self._hash[r] - self._mul(self._hash[l], RollingHash.base_pow[r-l])",
      "        return res if res >= 0 else res + RollingHash.MOD",
      "    ",
      "    def is_palindrome(self, l: int, r: int) -> bool:",
      "        \"\"\"[l, r)が回文か\"\"\"",
      "        assert 0 <= l <= r <= len(self), f\"index error [l,r)=[{l},{r})\"",
      "        self.make_reverse()",
      "        return self(l, r) == self._rev_hash(len(self)-r, len(self)-l)",
      "    ",
      "    def make_reverse(self) -> \"RollingHash\":",
      "        \"\"\"逆向きのインスタンスを生成\"\"\"",
      "        if not hasattr(self, \"_rev_hash\"):",
      "            self._rev_hash = RollingHash(self.string[::-1])",
      "        return self._rev_hash",
      "    ",
      "    def _calc_mod(self, x: int) -> int:",
      "        xu, xd = x >> 61, x & RollingHash.MASK61",
      "        res = xu + xd",
      "        return res if res < RollingHash.MOD else res - RollingHash.MOD",
      "",
      "    def _mul(self, a: int, b: int) -> int:",
      "        au, ad = a >> 31, a & RollingHash.MASK31",
      "        bu, bd = b >> 31, b & RollingHash.MASK31",
      "        mid = ad * bu + au * bd",
      "        midu, midd = mid >> 30, mid & RollingHash.MASK30",
      "        return self._calc_mod(au * bu * 2 + midu + (midd << 31) + ad * bd)",
      "    ",
      "    def _make_base_pow(self, x: int) -> None:",
      "        l = len(RollingHash.base_pow)",
      "        for _ in range(x - l + 1):",
      "            RollingHash.base_pow.append(self._mul(RollingHash.base, RollingHash.base_pow[-1]))",
      "    ",
      "    @staticmethod",
      "    def join(hash_s: int, hash_t: int, len_t: int) -> int:",
      "        \"\"\"s,tをこの順に結合した文字列のhash値\"\"\"",
      "        return ((hash_s * RollingHash.base_pow[len_t]) % RollingHash.MOD + hash_t) % RollingHash.MOD",
      "    "
    ],
    "description": "Auto snippet for RollingHash"
  },
  "Trie": {
    "prefix": "class Trie",
    "body": [
      "class Trie:",
      "    \"\"\"",
      "    多重集合",
      "",
      "    Methods:",
      "        add(string)                    : 文字列を追加。O(|S|)",
      "        discard(string)                : 文字列を削除。O(|S|)",
      "        contains(string)               : 文字列が存在するか。O(|S|)",
      "        contains_prefix(string)        : stringの接頭辞である文字列が存在するか。O(|S|)",
      "        count_lcp(string)              : stringとのLCPの長さが i である文字列の個数。O(|S|)",
      "        count_words_with_prefix(prefix): prefixで始まる文字列の個数。O(|S|)",
      "        get_words_with_prefix(prefix)  : prefixで始まる文字列を辞書順に列挙。計算量は、答えとなる文字列の長さの合計",
      "        count_all_words()              : この木に入っているすべての文字列の個数。O(1)",
      "        get_all_words()                : すべての文字列を辞書順に列挙。計算量は、答えとなる文字列の長さの合計",
      "        get_kth_word(k)                : 辞書順でk番目の要素を取得(0-indexed)。O(木の高さ)？",
      "    \"\"\"",
      "    class Node:",
      "        \"\"\"",
      "        根からこのノードまでつなげた文字列を",
      "        この文字列と呼ぶことにする",
      "",
      "        Attributes:",
      "            char        : このノードの文字",
      "            children    : 子ノード",
      "            prefix_count: この文字列がprefixである文字列の個数",
      "            word_count  : この文字列の個数",
      "        \"\"\"",
      "        def __init__(self, char: str = \"\") -> None:",
      "            self.char = char",
      "            self.children = {} #長さ26の配列も試したが、あまり変わらず",
      "            self.prefix_count = 0",
      "            self.word_count = 0",
      "        ",
      "        def is_end(self) -> bool:",
      "            \"\"\"ある文字列の最後の文字であるか\"\"\"",
      "            return self.word_count > 0",
      "        ",
      "        def __repr__(self) -> str:",
      "            return self.char",
      "    ",
      "    def __init__(self) -> None:",
      "        self.root = Trie.Node()",
      "",
      "    def __len__(self) -> int:",
      "        \"\"\"文字列の個数\"\"\"",
      "        return self.count_all_words()",
      "    ",
      "    def __contains__(self, string: str) -> bool:",
      "        \"\"\"stringが存在するか\"\"\"",
      "        return self.contains(string)",
      "    ",
      "    def __getitem__(self, k: int) -> str:",
      "        \"\"\"辞書順でk番目の要素を取得(0-indexed)\"\"\"",
      "        return self.get_kth_word(k)",
      "    ",
      "    def __repr__(self) -> str:",
      "        return f'Trie {self.get_all_words()}'",
      "    ",
      "    def add(self, string: str) -> None:",
      "        \"\"\"stringを追加\"\"\"",
      "        self.root.prefix_count += 1",
      "        current = self.root",
      "        for char in string:",
      "            if char not in current.children:",
      "                current.children[char] = Trie.Node(char)",
      "            current = current.children[char]",
      "            current.prefix_count += 1",
      "        current.word_count += 1",
      "    ",
      "    def discard(self, string: str) -> None:",
      "        \"\"\"stringを削除\"\"\"",
      "        if not self.contains(string):",
      "            return",
      "        self.root.prefix_count -= 1",
      "        current = self.root",
      "        for char in string:",
      "            current.children[char].prefix_count -= 1",
      "            if current.children[char].prefix_count == 0:",
      "                del current.children[char]",
      "                return",
      "            current = current.children[char]",
      "        current.word_count -= 1",
      "    ",
      "    def contains(self, string: str) -> bool:",
      "        \"\"\"stringが存在するか\"\"\"",
      "        node = self._traverse(string)",
      "        if node is None:",
      "            return False",
      "        return node.is_end()",
      "    ",
      "    def contains_prefix(self, string: str) -> bool:",
      "        \"\"\"stringの接頭辞である文字列が存在するか\"\"\"",
      "        current = self.root",
      "        for char in string:",
      "            if char not in current.children:",
      "                return False",
      "            current = current.children[char]",
      "            if current.is_end():",
      "                return True",
      "        return False",
      "    ",
      "    def count_lcp(self, string: str) -> list[int]:",
      "        \"\"\"stringとのLCPの長さが i である文字列の個数\"\"\"",
      "        current = self.root",
      "        #先頭i文字が等しい文字列の個数を数えてから",
      "        lcp_count = [self.count_all_words()] + [0] * len(string)",
      "        for i, char in enumerate(string, 1):",
      "            if char not in current.children:",
      "                break",
      "            current = current.children[char]",
      "            lcp_count[i] = current.prefix_count",
      "",
      "        for i in range(len(string)):",
      "            lcp_count[i] -= lcp_count[i+1]",
      "        return lcp_count",
      "    ",
      "    def count_words_with_prefix(self, prefix: str) -> int:",
      "        \"\"\"prefixで始まる文字列の個数\"\"\"",
      "        node = self._traverse(prefix)",
      "        if node is None:",
      "            return 0",
      "        return node.prefix_count",
      "    ",
      "    def get_words_with_prefix(self, prefix: str) -> list[str]:",
      "        \"\"\"prefixで始まる文字列を辞書順に列挙\"\"\"",
      "        node = self._traverse(prefix)",
      "        if node is None:",
      "            return []",
      "",
      "        words = []",
      "        word = [prefix[:-1]]",
      "        stack = [node]",
      "        while stack: #dfs",
      "            node = stack.pop()",
      "            if node is None: #帰りなら",
      "                word.pop()",
      "                continue",
      "            word.append(node.char)",
      "            #ノードが終端ならその数だけ答えに追加",
      "            words.extend([''.join(word) for _ in range(node.word_count)])",
      "            stack.append(None) #帰り用",
      "            for _, next in sorted(node.children.items(), reverse=True):",
      "                stack.append(next)",
      "        return words",
      "    ",
      "    def count_all_words(self) -> int:",
      "        \"\"\"この木に入っているすべての文字列の個数\"\"\"",
      "        return self.count_words_with_prefix(\"\")",
      "    ",
      "    def get_all_words(self) -> list[str]:",
      "        \"\"\"すべての文字列を辞書順に列挙\"\"\"",
      "        return self.get_words_with_prefix(\"\")",
      "    ",
      "    def get_kth_word(self, k: int) -> str:",
      "        \"\"\"辞書順でk番目の要素を取得(0-indexed)\"\"\"",
      "        assert k < self.count_all_words(), f'{k}th string is not found'",
      "        current = self.root",
      "        string = []",
      "        while k >= 0:",
      "            for char, node in sorted(current.children.items()):",
      "                if node.prefix_count > k:",
      "                    current = node",
      "                    string.append(char)",
      "                    k -= current.word_count",
      "                    break",
      "                k -= node.prefix_count",
      "        return ''.join(string)",
      "    ",
      "    def _traverse(self, string: str) -> Node | None:",
      "        \"\"\"stringに基づいてノードをたどる\"\"\"",
      "        current = self.root",
      "        for char in string:",
      "            if char not in current.children:",
      "                return None",
      "            current = current.children[char]",
      "        return current"
    ],
    "description": "Auto snippet for Trie"
  },
  "z_algorithm": {
    "prefix": "def z_algorithm",
    "body": [
      "def z_algorithm(s: str) -> list[int]:",
      "    \"\"\"sとs[i:]のLCPの長さ\"\"\"",
      "    z = [0] * len(s)",
      "    z[0] = len(s)",
      "    l = r = 0",
      "    for i in range(1, len(s)):",
      "        if z[i-l] < r-i:",
      "            z[i] = z[i-l]",
      "            continue",
      "        r = max(r, i)",
      "        while r < len(s) and s[r] == s[r-i]:",
      "            r += 1",
      "        z[i] = r-i",
      "        l = i",
      "    return z"
    ],
    "description": "Auto snippet for z_algorithm"
  }
}